// This file is @generated by prost-build.
/// RGB color (0-255 per channel)
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Color {
    #[prost(uint32, tag = "1")]
    pub r: u32,
    #[prost(uint32, tag = "2")]
    pub g: u32,
    #[prost(uint32, tag = "3")]
    pub b: u32,
}
/// Terminal theme with 16 ANSI colors
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThemeInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub background: ::core::option::Option<Color>,
    #[prost(message, optional, tag = "3")]
    pub foreground: ::core::option::Option<Color>,
    /// 8 colors (indices 0-7)
    #[prost(message, repeated, tag = "4")]
    pub normal: ::prost::alloc::vec::Vec<Color>,
    /// 8 colors (indices 8-15)
    #[prost(message, repeated, tag = "5")]
    pub bright: ::prost::alloc::vec::Vec<Color>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerMessage {
    #[prost(
        oneof = "server_message::Message",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24"
    )]
    pub message: ::core::option::Option<server_message::Message>,
}
/// Nested message and enum types in `ServerMessage`.
pub mod server_message {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Message {
        #[prost(message, tag = "1")]
        Output(super::Output),
        #[prost(message, tag = "2")]
        Resize(super::Resize),
        #[prost(message, tag = "3")]
        Title(super::Title),
        #[prost(message, tag = "4")]
        Connected(super::Connected),
        #[prost(message, tag = "5")]
        Refresh(super::Refresh),
        #[prost(message, tag = "6")]
        Cursor(super::CursorPosition),
        #[prost(message, tag = "7")]
        Bell(super::Bell),
        #[prost(message, tag = "8")]
        Error(super::Error),
        #[prost(message, tag = "9")]
        Shutdown(super::Shutdown),
        #[prost(message, tag = "10")]
        Pong(super::Pong),
        #[prost(message, tag = "11")]
        CwdChanged(super::CwdChanged),
        #[prost(message, tag = "12")]
        TriggerMatched(super::TriggerMatched),
        #[prost(message, tag = "13")]
        ActionNotify(super::ActionNotify),
        #[prost(message, tag = "14")]
        ActionMarkLine(super::ActionMarkLine),
        #[prost(message, tag = "15")]
        ModeChanged(super::ModeChanged),
        #[prost(message, tag = "16")]
        GraphicsAdded(super::GraphicsAdded),
        #[prost(message, tag = "17")]
        HyperlinkAdded(super::HyperlinkAdded),
        #[prost(message, tag = "18")]
        UserVarChanged(super::UserVarChanged),
        #[prost(message, tag = "19")]
        ProgressBarChanged(super::ProgressBarChanged),
        #[prost(message, tag = "20")]
        BadgeChanged(super::BadgeChanged),
        #[prost(message, tag = "21")]
        SelectionChanged(super::SelectionChanged),
        #[prost(message, tag = "22")]
        ClipboardSync(super::ClipboardSync),
        #[prost(message, tag = "23")]
        ShellIntegrationEvent(super::ShellIntegrationEvent),
        #[prost(message, tag = "24")]
        SystemStats(super::SystemStats),
    }
}
/// Terminal output data (very high frequency)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Output {
    /// UTF-8 encoded terminal output with ANSI codes
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// Unix epoch milliseconds
    #[prost(uint64, optional, tag = "2")]
    pub timestamp: ::core::option::Option<u64>,
}
/// Terminal resize notification
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Resize {
    #[prost(uint32, tag = "1")]
    pub cols: u32,
    #[prost(uint32, tag = "2")]
    pub rows: u32,
}
/// Terminal title change
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Title {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
}
/// Initial connection handshake
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Connected {
    #[prost(uint32, tag = "1")]
    pub cols: u32,
    #[prost(uint32, tag = "2")]
    pub rows: u32,
    /// ANSI styled screen content
    #[prost(bytes = "vec", optional, tag = "3")]
    pub initial_screen: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, tag = "4")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub theme: ::core::option::Option<ThemeInfo>,
    /// Current badge text
    #[prost(string, optional, tag = "6")]
    pub badge: ::core::option::Option<::prost::alloc::string::String>,
    /// Dim text alpha (0.0-1.0)
    #[prost(float, optional, tag = "7")]
    pub faint_text_alpha: ::core::option::Option<f32>,
    /// Current working directory
    #[prost(string, optional, tag = "8")]
    pub cwd: ::core::option::Option<::prost::alloc::string::String>,
    /// modifyOtherKeys mode (0-2)
    #[prost(uint32, optional, tag = "9")]
    pub modify_other_keys: ::core::option::Option<u32>,
    /// Unique client identifier
    #[prost(string, optional, tag = "10")]
    pub client_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether this connection is read-only
    #[prost(bool, optional, tag = "11")]
    pub readonly: ::core::option::Option<bool>,
}
/// Full screen refresh response
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Refresh {
    #[prost(uint32, tag = "1")]
    pub cols: u32,
    #[prost(uint32, tag = "2")]
    pub rows: u32,
    /// ANSI styled screen content
    #[prost(bytes = "vec", tag = "3")]
    pub screen_content: ::prost::alloc::vec::Vec<u8>,
}
/// Cursor position update
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CursorPosition {
    #[prost(uint32, tag = "1")]
    pub col: u32,
    #[prost(uint32, tag = "2")]
    pub row: u32,
    #[prost(bool, tag = "3")]
    pub visible: bool,
}
/// Bell/alert event
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Bell {}
/// CWD change notification (OSC 7)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CwdChanged {
    #[prost(string, optional, tag = "1")]
    pub old_cwd: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub new_cwd: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3")]
    pub hostname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub username: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "5")]
    pub timestamp: ::core::option::Option<u64>,
}
/// Trigger pattern matched
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TriggerMatched {
    #[prost(uint64, tag = "1")]
    pub trigger_id: u64,
    #[prost(uint32, tag = "2")]
    pub row: u32,
    #[prost(uint32, tag = "3")]
    pub col: u32,
    #[prost(uint32, tag = "4")]
    pub end_col: u32,
    #[prost(string, tag = "5")]
    pub text: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub captures: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint64, tag = "7")]
    pub timestamp: u64,
}
/// Trigger action result: notification
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ActionNotify {
    #[prost(uint64, tag = "1")]
    pub trigger_id: u64,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
/// Trigger action result: mark/bookmark a line
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ActionMarkLine {
    #[prost(uint64, tag = "1")]
    pub trigger_id: u64,
    #[prost(uint32, tag = "2")]
    pub row: u32,
    #[prost(string, optional, tag = "3")]
    pub label: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub color: ::core::option::Option<Color>,
}
/// Error notification
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Error {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub code: ::core::option::Option<::prost::alloc::string::String>,
}
/// Server shutdown notification
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Shutdown {
    #[prost(string, tag = "1")]
    pub reason: ::prost::alloc::string::String,
}
/// Keepalive pong response
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Pong {}
/// Terminal mode changed (cursor visibility, mouse tracking, etc.)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ModeChanged {
    /// Mode name (e.g., "cursor_visible", "mouse_tracking")
    #[prost(string, tag = "1")]
    pub mode: ::prost::alloc::string::String,
    /// Whether the mode is enabled
    #[prost(bool, tag = "2")]
    pub enabled: bool,
}
/// Graphics/image added to terminal (Sixel, iTerm2, Kitty)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GraphicsAdded {
    /// Row where graphics were added
    #[prost(uint32, tag = "1")]
    pub row: u32,
    /// Graphics format ("sixel", "iterm2", "kitty")
    #[prost(string, optional, tag = "2")]
    pub format: ::core::option::Option<::prost::alloc::string::String>,
}
/// Hyperlink added (OSC 8)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HyperlinkAdded {
    /// The URL of the hyperlink
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// Row where the hyperlink appears
    #[prost(uint32, tag = "2")]
    pub row: u32,
    /// Column where hyperlink starts
    #[prost(uint32, tag = "3")]
    pub col: u32,
    /// Optional hyperlink ID from OSC 8
    #[prost(string, optional, tag = "4")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
}
/// User variable changed (OSC 1337 SetUserVar)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserVarChanged {
    /// Variable name
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// New value (base64-decoded)
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
    /// Previous value if it existed
    #[prost(string, optional, tag = "3")]
    pub old_value: ::core::option::Option<::prost::alloc::string::String>,
}
/// Named progress bar changed (OSC 934)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProgressBarChanged {
    /// "set", "remove", or "remove_all"
    #[prost(string, tag = "1")]
    pub action: ::prost::alloc::string::String,
    /// Progress bar identifier
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    /// State name (only for "set")
    #[prost(string, optional, tag = "3")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
    /// Progress percentage 0-100 (only for "set")
    #[prost(uint32, optional, tag = "4")]
    pub percent: ::core::option::Option<u32>,
    /// Descriptive label (only for "set")
    #[prost(string, optional, tag = "5")]
    pub label: ::core::option::Option<::prost::alloc::string::String>,
}
/// Badge text changed (OSC 1337 SetBadgeFormat)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BadgeChanged {
    /// New badge text (empty if cleared)
    #[prost(string, optional, tag = "1")]
    pub badge: ::core::option::Option<::prost::alloc::string::String>,
}
/// Selection changed
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SelectionChanged {
    #[prost(uint32, optional, tag = "1")]
    pub start_col: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub start_row: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub end_col: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub end_row: ::core::option::Option<u32>,
    /// Selected text content
    #[prost(string, optional, tag = "5")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
    /// "chars", "line", "block"
    #[prost(string, tag = "6")]
    pub mode: ::prost::alloc::string::String,
    /// True if selection was cleared
    #[prost(bool, tag = "7")]
    pub cleared: bool,
}
/// Clipboard sync event (OSC 52)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClipboardSync {
    /// "set", "get_response"
    #[prost(string, tag = "1")]
    pub operation: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    /// "clipboard", "primary", "select"
    #[prost(string, optional, tag = "3")]
    pub target: ::core::option::Option<::prost::alloc::string::String>,
}
/// Shell integration event (FinalTerm sequences)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ShellIntegrationEvent {
    /// "prompt_start", "command_start", "command_executed", "command_finished"
    #[prost(string, tag = "1")]
    pub event_type: ::prost::alloc::string::String,
    /// The command text (for command_start)
    #[prost(string, optional, tag = "2")]
    pub command: ::core::option::Option<::prost::alloc::string::String>,
    /// Exit code (for command_finished)
    #[prost(int32, optional, tag = "3")]
    pub exit_code: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "4")]
    pub timestamp: ::core::option::Option<u64>,
    /// Absolute cursor line (scrollback_len + cursor_row) at marker time
    #[prost(uint64, optional, tag = "5")]
    pub cursor_line: ::core::option::Option<u64>,
}
/// CPU statistics
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CpuStats {
    #[prost(double, tag = "1")]
    pub overall_usage_percent: f64,
    #[prost(uint32, tag = "2")]
    pub physical_core_count: u32,
    #[prost(double, repeated, tag = "3")]
    pub per_core_usage_percent: ::prost::alloc::vec::Vec<f64>,
    #[prost(string, optional, tag = "4")]
    pub brand: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "5")]
    pub frequency_mhz: ::core::option::Option<u64>,
}
/// Memory statistics
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MemoryStats {
    #[prost(uint64, tag = "1")]
    pub total_bytes: u64,
    #[prost(uint64, tag = "2")]
    pub used_bytes: u64,
    #[prost(uint64, tag = "3")]
    pub available_bytes: u64,
    #[prost(uint64, tag = "4")]
    pub swap_total_bytes: u64,
    #[prost(uint64, tag = "5")]
    pub swap_used_bytes: u64,
}
/// Individual disk statistics
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DiskStats {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub mount_point: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub total_bytes: u64,
    #[prost(uint64, tag = "4")]
    pub available_bytes: u64,
    #[prost(string, tag = "5")]
    pub kind: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub file_system: ::prost::alloc::string::String,
    #[prost(bool, tag = "7")]
    pub is_removable: bool,
}
/// Network interface statistics
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetworkInterfaceStats {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub received_bytes: u64,
    #[prost(uint64, tag = "3")]
    pub transmitted_bytes: u64,
    #[prost(uint64, tag = "4")]
    pub total_received_bytes: u64,
    #[prost(uint64, tag = "5")]
    pub total_transmitted_bytes: u64,
    #[prost(uint64, tag = "6")]
    pub packets_received: u64,
    #[prost(uint64, tag = "7")]
    pub packets_transmitted: u64,
    #[prost(uint64, tag = "8")]
    pub errors_received: u64,
    #[prost(uint64, tag = "9")]
    pub errors_transmitted: u64,
}
/// System load averages
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LoadAverage {
    #[prost(double, tag = "1")]
    pub one_minute: f64,
    #[prost(double, tag = "2")]
    pub five_minutes: f64,
    #[prost(double, tag = "3")]
    pub fifteen_minutes: f64,
}
/// Combined system resource statistics
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemStats {
    #[prost(message, optional, tag = "1")]
    pub cpu: ::core::option::Option<CpuStats>,
    #[prost(message, optional, tag = "2")]
    pub memory: ::core::option::Option<MemoryStats>,
    #[prost(message, repeated, tag = "3")]
    pub disks: ::prost::alloc::vec::Vec<DiskStats>,
    #[prost(message, repeated, tag = "4")]
    pub networks: ::prost::alloc::vec::Vec<NetworkInterfaceStats>,
    #[prost(message, optional, tag = "5")]
    pub load_average: ::core::option::Option<LoadAverage>,
    #[prost(string, optional, tag = "6")]
    pub hostname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    pub os_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "8")]
    pub os_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "9")]
    pub kernel_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "10")]
    pub uptime_secs: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "11")]
    pub timestamp: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClientMessage {
    #[prost(
        oneof = "client_message::Message",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10"
    )]
    pub message: ::core::option::Option<client_message::Message>,
}
/// Nested message and enum types in `ClientMessage`.
pub mod client_message {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Message {
        #[prost(message, tag = "1")]
        Input(super::Input),
        #[prost(message, tag = "2")]
        Resize(super::ClientResize),
        #[prost(message, tag = "3")]
        Ping(super::Ping),
        #[prost(message, tag = "4")]
        Refresh(super::RequestRefresh),
        #[prost(message, tag = "5")]
        Subscribe(super::Subscribe),
        #[prost(message, tag = "6")]
        Mouse(super::MouseInput),
        #[prost(message, tag = "7")]
        Focus(super::FocusChange),
        #[prost(message, tag = "8")]
        Paste(super::PasteInput),
        #[prost(message, tag = "9")]
        Selection(super::SelectionRequest),
        #[prost(message, tag = "10")]
        Clipboard(super::ClipboardRequest),
    }
}
/// Keyboard input from client
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Input {
    /// UTF-8 encoded input (may include escape sequences)
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Client requests terminal resize
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClientResize {
    #[prost(uint32, tag = "1")]
    pub cols: u32,
    #[prost(uint32, tag = "2")]
    pub rows: u32,
}
/// Keepalive ping request
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Ping {}
/// Client requests full screen refresh
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestRefresh {}
/// Client subscribes to specific event types
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Subscribe {
    #[prost(enumeration = "EventType", repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<i32>,
}
/// Mouse input from client
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MouseInput {
    #[prost(uint32, tag = "1")]
    pub col: u32,
    #[prost(uint32, tag = "2")]
    pub row: u32,
    /// 0=left, 1=middle, 2=right, 3=release, 4=scroll_up, 5=scroll_down
    #[prost(uint32, tag = "3")]
    pub button: u32,
    #[prost(bool, tag = "4")]
    pub shift: bool,
    #[prost(bool, tag = "5")]
    pub ctrl: bool,
    #[prost(bool, tag = "6")]
    pub alt: bool,
    /// "press", "release", "move", "scroll"
    #[prost(string, tag = "7")]
    pub event_type: ::prost::alloc::string::String,
}
/// Focus change from client
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FocusChange {
    #[prost(bool, tag = "1")]
    pub focused: bool,
}
/// Paste input from client
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PasteInput {
    #[prost(string, tag = "1")]
    pub content: ::prost::alloc::string::String,
}
/// Selection request from client
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SelectionRequest {
    #[prost(uint32, tag = "1")]
    pub start_col: u32,
    #[prost(uint32, tag = "2")]
    pub start_row: u32,
    #[prost(uint32, tag = "3")]
    pub end_col: u32,
    #[prost(uint32, tag = "4")]
    pub end_row: u32,
    /// "chars", "line", "block", "word", "clear"
    #[prost(string, tag = "5")]
    pub mode: ::prost::alloc::string::String,
}
/// Clipboard request from client
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClipboardRequest {
    /// "set", "get"
    #[prost(string, tag = "1")]
    pub operation: ::prost::alloc::string::String,
    /// Content for "set" operations
    #[prost(string, optional, tag = "2")]
    pub content: ::core::option::Option<::prost::alloc::string::String>,
    /// "clipboard", "primary", "select"
    #[prost(string, optional, tag = "3")]
    pub target: ::core::option::Option<::prost::alloc::string::String>,
}
/// Event types for subscription
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EventType {
    Unspecified = 0,
    Output = 1,
    Cursor = 2,
    Bell = 3,
    Title = 4,
    Resize = 5,
    Cwd = 6,
    Trigger = 7,
    Action = 8,
    Mode = 9,
    Graphics = 10,
    Hyperlink = 11,
    UserVar = 12,
    ProgressBar = 13,
    Badge = 14,
    Selection = 15,
    Clipboard = 16,
    Shell = 17,
    SystemStats = 18,
}
impl EventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "EVENT_TYPE_UNSPECIFIED",
            Self::Output => "EVENT_TYPE_OUTPUT",
            Self::Cursor => "EVENT_TYPE_CURSOR",
            Self::Bell => "EVENT_TYPE_BELL",
            Self::Title => "EVENT_TYPE_TITLE",
            Self::Resize => "EVENT_TYPE_RESIZE",
            Self::Cwd => "EVENT_TYPE_CWD",
            Self::Trigger => "EVENT_TYPE_TRIGGER",
            Self::Action => "EVENT_TYPE_ACTION",
            Self::Mode => "EVENT_TYPE_MODE",
            Self::Graphics => "EVENT_TYPE_GRAPHICS",
            Self::Hyperlink => "EVENT_TYPE_HYPERLINK",
            Self::UserVar => "EVENT_TYPE_USER_VAR",
            Self::ProgressBar => "EVENT_TYPE_PROGRESS_BAR",
            Self::Badge => "EVENT_TYPE_BADGE",
            Self::Selection => "EVENT_TYPE_SELECTION",
            Self::Clipboard => "EVENT_TYPE_CLIPBOARD",
            Self::Shell => "EVENT_TYPE_SHELL",
            Self::SystemStats => "EVENT_TYPE_SYSTEM_STATS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "EVENT_TYPE_OUTPUT" => Some(Self::Output),
            "EVENT_TYPE_CURSOR" => Some(Self::Cursor),
            "EVENT_TYPE_BELL" => Some(Self::Bell),
            "EVENT_TYPE_TITLE" => Some(Self::Title),
            "EVENT_TYPE_RESIZE" => Some(Self::Resize),
            "EVENT_TYPE_CWD" => Some(Self::Cwd),
            "EVENT_TYPE_TRIGGER" => Some(Self::Trigger),
            "EVENT_TYPE_ACTION" => Some(Self::Action),
            "EVENT_TYPE_MODE" => Some(Self::Mode),
            "EVENT_TYPE_GRAPHICS" => Some(Self::Graphics),
            "EVENT_TYPE_HYPERLINK" => Some(Self::Hyperlink),
            "EVENT_TYPE_USER_VAR" => Some(Self::UserVar),
            "EVENT_TYPE_PROGRESS_BAR" => Some(Self::ProgressBar),
            "EVENT_TYPE_BADGE" => Some(Self::Badge),
            "EVENT_TYPE_SELECTION" => Some(Self::Selection),
            "EVENT_TYPE_CLIPBOARD" => Some(Self::Clipboard),
            "EVENT_TYPE_SHELL" => Some(Self::Shell),
            "EVENT_TYPE_SYSTEM_STATS" => Some(Self::SystemStats),
            _ => None,
        }
    }
}
